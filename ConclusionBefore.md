# 网络编程总结
## 2018.11.12
### 1.unix信号sig:
    * signal(//SIGPIPE, //SIG_IGN)函数用于注册回调函数或忽略某一个信号,libevent将其封装为事件来处理
    * 可以使用kill函数来给进程发各种信号kill(pid, SIGPIPE),当在终端的父进程给子进程发送各种可杀死子进程的信号时,子进程会死亡，但终端不会有任何信号信息,子进程给父进程发送死亡信号时,父进程死亡,且打印信号信息(系统自动打印),另有父子进程死亡问题下文描述
    * 部分sig信号如:SIGSEGV会引发吐核(core dump),此时若开启内存转储可使用gdb调试错误(SIGSEGV一般在野指针空指针等出现)
### 2.进程线程回收(SIGCHILD信号的处理):
    进程回收一般是使用waitpid或wait,这两个调用堵塞直到任一个进程结束后收回资源,但是pthread_join()这个调用只能等待指定的线程结束,若指定进程未结束,他会一直堵塞,即使另一个线程已经结束需要回收(可能是设计缺陷),但是可以使用pthread_detach来分离线程,使该线程成为守护线程,结束后由运行时的库回收  
### 3.父子进程死亡问题:
    进程在结束之后系统会保留一些执行信息供使用者察看,若不使用wait等回收这些资源进程则会变成僵尸进程，占用系统资源.但当父进程结束(死亡)后,这些僵尸进程都消失了,这是因为父进程死亡,子进程成为孤儿进程,交由init进程管理,他会管理并释放这些子进程(直到子进程完成工作才释放),当父进程中途死亡,子进程也是交由init进程管理
### 4.TCP各种细节问题:
        TCP通过滑动窗口来解决tcp包乱序包重复等问题,还可通过ack包中通知对端窗口大小来控制传输,防止对端包淹没本端接受缓冲区(使用ack包中的win 0); 0窗口又引发另一个问题:当本端缓冲区恢复,发送ack让对端可以重新开始传输时,若ack丢失本端是不会重发的,这时就成了一条死连接，只要双方都不互发信息,他们将永远无法知道对方是否还存活(假设不设keepalive socketopt);此时就需要零窗口探测器(对端实现),零窗口探测器通过退避的方式发送ack,强迫本端回复窗口信息,若对方长时间未回复将因超时，本端将断开连接
        TIME_WAIT状态:TIME_WAIT状态是为防止失而复现分节造成错误而存在,他的时间为2倍分节在网络中的最长生命期限，因此他禁止在此状态下bind绑定相同的ip和端口,因为ip端口相同时,失而复现分节将被传到新连接造成错误,因此这个状态不能随意放弃
        通过设置socketopt linger可使程序在调用close时给对端发送rst,同时丢弃连接的所有信息,此时即没有time_wait状态(但这种做法仅在处理繁忙业务时推荐使用),不过也可使用该socketopt发送rst包(待测试)
        当read和write在接受到rst之后调用会返回-1,同时错误代码为ECONNRST,在read和write在堵塞时接受到rst时(未检验),个人认为会返回已读已写字节数(一般不会和他们的第三个参数相同)(待测试)
        当调用send之后协议在发送中且未发送完毕时接受到对方的FIN时,write和read如果此时是堵塞的则直接返回 且返回已读已写字节数(一般不会和他们的第三个参数相同)
        本端主动发送FIN将进入FIN_WAIT1状态,若此时对端的ack丢失,按照tcp理想模型应该一直处于FIN_WAIT1状态,因为ack不会重发,但实际上FIN_WAIT1 2都有一个计时器计超时返回(待验证)
        socketopt  SO_REUSEADDR可用于重用端口,去除TIME_WAIT状态影响
        当一端调用close时发送fin,另一端则必须执行挥手,本端FIN由系统发送而不是调用close才发送,所以再write返回-1,read返回0,另一端的FIN和ack一起发送,因此tcpdump无法捕捉到此FIN(经受时延的确认(Delay ACK))
        当在收到对端的FIN后,本端read和write(测试较少字节数:100),前3次write都返回正常字节(第三个参数),第四次开始返回0.read一直返回0,能捕捉到FIN和RST
        当对端设置LINGER后,对端发送rst,本端read和write(100字节),前3次write都返回-1,第一次错误为PeerReSet，后面都为broken pipe(SIG_IGN),第四次write开始返回0,read第一次返回-1,其他都是0
        对端不设LINGER,调close发送FIN,本端write在收FIN之前已堵塞(缓冲区已满),收到FIN后立刻返回,返回值(约200000)小于第三个参数(非常大:1024 * 1024 * 5)之后read write返回-1, 若在接受FIN之后一段时间(20s)write，返回值比之前的小很多(约20000),write是由于对端发来的RST返回的
        发送rst的一端是将连接的所有信息都抛弃了，而接受rst的一方一般read write返回-1,也有例外
        当两个连接连接后不互发信息无法确认对方死活(不设keepalive)，一方断电若不互通数据就会造成死链接,若互发信息则会引发重传(详细见百度),最后超时(是否发rst未知)
        在传输过程中(假设服务端不停收,客户端不停发)，因为接受端快,read函数(第三个参数很大)返回值远小于第三个参数,(如果先sleep()再收,返回值会大些),write函数(第三个参数特大)则返回值正常情况下都为第三个参数或着处于堵塞状态，此时，中断网络链接(拔网线)，因为没有数据再达到,read把缓冲区数据读走,后堵塞于下一个read,而write则不断写入缓冲区直到发送缓冲区满堵塞,而缓冲区不会减小，因为数据传不过去,因为等不到对端ack,数据会被重发(退避),最后超时，返回已写入字节数. 模拟网络不通的方法:因为切断网络,tcpdump无法抓到重传包,我在服务器使用sudo iptables -A INPUT -p tcp --dport 10000(端口号) -j DROP这条命令丢弃所有来自10000端口的包模拟断网,之后可以通过tcpdump抓到重发包 sudo iptables -D INPUT 1可以删除过滤规则  sudo iptables -L -n --line-numbers 显示规则行数 
        强调write返回的是已写入发送缓冲区字节数,而不是已发送的
        TIME_WAIT状态存在有两点原因:1.防止失而复现分节 2.维护最终的FIN,如果ACK丢失可重发FIN
